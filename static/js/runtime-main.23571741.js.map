{"version":3,"sources":["../webpack/bootstrap","../../../../../BOUALI~1.KAM/AppData/Local/Temp/tmp-25005Jyaz3xCzWdp/dojo/dojo.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","41","exports","module","l","e","promises","installedChunkData","promise","Promise","resolve","reject","onScriptComplete","script","document","createElement","charset","timeout","nc","setAttribute","src","p","jsonpScriptSrc","error","Error","event","onerror","onload","clearTimeout","chunk","errorType","type","realSrc","target","message","name","request","undefined","setTimeout","head","appendChild","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","err","console","jsonpArray","this","oldJsonpFunction","slice","toUrl","referenceModule","loaderScope","require","toAbsMid","req","config","dependencies","callback","contextRequire","registerAbsMids","absMids","absMidsById","findModule","mid","noInstall","asModuleObj","split","map","segment","charAt","join","a1","a2","a3","__DOJO_WEBPACK_DEFINE_PROMISE__","errors","forEach","info","signal","async","globalObj","window","dj","undef","webpackModule","id","set","configurable","h","expr","normalize","arg","global","dojoConfig","userConfig","dest","mix","defaultConfig","filename","indexOf","absMid","originalToAbsMid","pkgName","substring","pkg","packs","realMain","url","originalToUrl","parts","test","baseUrl","keys","main","reduce","acc","pathComp","loaderVersion","globalObject","self","noop","toString","isFunction","it","vector","uidSeed","doc","element","has","hasCache","cache","add","now","force","eval_","eval","text","hint","listenerQueues","on","args","queue","listener","remove","aliases","pathsMapProg","mapProgs","cacheBust","paths","rawConfig","runMapProg","targetMid","compactPath","path","lastSegment","replace","pop","makeModuleInfo","pid","pack","executed","def","getModuleInfo_","alwaysCreate","fromPendingCache","midInPackage","mapItem","isRelative","makeError","star","match","candidate","pair","location","getModuleInfo","fixupUrl","moduleInfo","log","trace","loaderPatch","uid","define"],"mappings":"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","file":"static/js/runtime-main.23571741.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t41: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"static/js/\" + ({}[chunkId]||chunkId) + \".\" + {\"0\":\"34278017\",\"1\":\"48a3dfbf\",\"2\":\"8a2c902a\",\"3\":\"be405011\",\"4\":\"a2f91caf\",\"5\":\"e049750c\",\"6\":\"a8979f49\",\"7\":\"3cc997a7\",\"8\":\"1ffa91a2\",\"9\":\"fd939ddb\",\"10\":\"add62300\",\"11\":\"1b41871b\",\"12\":\"e04bd386\",\"13\":\"19fb10c3\",\"14\":\"153c9d08\",\"15\":\"eb23ed9a\",\"16\":\"c90b7357\",\"17\":\"cb6ef743\",\"18\":\"bd1a4cbf\",\"19\":\"444b1964\",\"20\":\"8d5e7dee\",\"21\":\"385a64fa\",\"22\":\"23338cb8\",\"23\":\"aa593ceb\",\"24\":\"b9d079f3\",\"25\":\"b1c7a21a\",\"26\":\"abff86bb\",\"27\":\"b293cede\",\"28\":\"90981820\",\"29\":\"6ac0079a\",\"30\":\"02a55cfb\",\"31\":\"1432d05c\",\"32\":\"f3368997\",\"33\":\"7aa0a1cb\",\"34\":\"bbd23ac0\",\"35\":\"0a4e2b84\",\"36\":\"a99320e1\",\"37\":\"da6717d8\",\"38\":\"62ea3fdb\",\"39\":\"502448b0\",\"42\":\"572cfe57\",\"43\":\"f7cf1f9a\",\"44\":\"2a9ce7d8\",\"45\":\"3eca9b87\",\"46\":\"26747dfd\",\"47\":\"b232669b\",\"48\":\"b195cb71\",\"49\":\"eb4e50f3\",\"50\":\"7111e8f2\",\"51\":\"d7c7975e\",\"52\":\"64730833\",\"53\":\"4040091b\",\"54\":\"34718967\",\"55\":\"aec4cf20\",\"56\":\"1f28a03d\",\"57\":\"1616d976\",\"58\":\"a975f751\",\"59\":\"25e0fe59\",\"60\":\"aad43f17\",\"61\":\"5e1e8d48\",\"62\":\"159992ed\",\"63\":\"dda6ff7e\",\"64\":\"e1886520\",\"65\":\"69caf423\",\"66\":\"5d84bf44\",\"67\":\"e727a494\",\"68\":\"27ee3264\",\"69\":\"fe9b3f09\",\"70\":\"a04f1165\",\"71\":\"e9237086\",\"73\":\"a5b0abe3\",\"74\":\"8f93c823\",\"75\":\"1b3a19b1\",\"76\":\"45f88ba1\",\"77\":\"62353882\",\"78\":\"17ec3fa7\",\"79\":\"beb9f8e0\",\"80\":\"c23e1824\",\"81\":\"4ab4dc82\",\"82\":\"ed2b71d8\",\"83\":\"df230ecc\",\"84\":\"c8542002\",\"85\":\"1352c5f1\",\"86\":\"0227045e\",\"87\":\"55a048da\",\"88\":\"758c96b7\",\"89\":\"76cee270\",\"90\":\"5c9a37b2\",\"91\":\"6dd251b7\",\"92\":\"7b626b7b\",\"93\":\"36fab1b6\",\"94\":\"85d5da04\",\"95\":\"11379104\",\"96\":\"8aa4bab0\",\"97\":\"62c80524\",\"98\":\"35e5514b\",\"99\":\"8b6bba88\",\"100\":\"198c52be\",\"101\":\"f2f8ac61\",\"102\":\"14e3e2bd\",\"103\":\"e73ae019\",\"104\":\"1cd8a146\",\"105\":\"1b243424\",\"106\":\"67072dc2\",\"107\":\"908ff915\",\"108\":\"6b72de9c\",\"109\":\"0190af9f\",\"110\":\"bc9277a7\",\"111\":\"a81f7c53\",\"112\":\"6965bb66\",\"113\":\"37de95c7\",\"114\":\"5d77d647\",\"115\":\"dffbbe1a\",\"116\":\"fb2c4699\",\"117\":\"ebbc41fd\",\"118\":\"6072fa43\",\"119\":\"df0e0248\",\"120\":\"40f6fac5\",\"121\":\"777934bd\",\"122\":\"09383d81\",\"123\":\"b9e56b9c\",\"124\":\"b452588a\",\"125\":\"c29525c4\",\"126\":\"454bd167\",\"127\":\"09dbee9a\",\"128\":\"866be780\",\"129\":\"007fe7c6\",\"130\":\"c2e53158\",\"131\":\"0df4c444\",\"132\":\"905f7d75\",\"133\":\"af82d8d2\",\"134\":\"03b680af\",\"135\":\"791f648b\",\"136\":\"e6c89c20\"}[chunkId] + \".chunk.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = this[\"webpackJsonpareactgis\"] = this[\"webpackJsonpareactgis\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t(function() { /* Start undefined extensions */\n \t\t\tfunction mix(dest, src) { // eslint-disable-line no-unused-vars\n \t\t\t\tfor(var n in src) dest[n] = src[n];\n \t\t\t\treturn dest;\n \t\t\t}\n\n \t\t\tfunction toUrl(name, referenceModule) {\n \t\t\t\treturn loaderScope.require.toUrl(name, referenceModule);\n \t\t\t}\n\n \t\t\tfunction toAbsMid(name, referenceModule) {\n \t\t\t\treturn loaderScope.require.toAbsMid(name, referenceModule);\n \t\t\t}\n\n \t\t\t// dojo require function.\n \t\t\tfunction req(config, dependencies, callback) {\n \t\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n \t\t\t};\n\n \t\t\tfunction createContextRequire(moduleId) { // eslint-disable-line no-unused-vars\n \t\t\t\tif (req.absMidsById[moduleId]) {\n \t\t\t\t\tmoduleId = req.absMidsById[moduleId];\n \t\t\t\t}\n \t\t\t\tif (!moduleId) return req;\n \t\t\t\tvar result = function(a1, a2, a3) {\n \t\t\t\t\treturn contextRequire(a1, a2, a3, moduleId, req);\n \t\t\t\t};\n \t\t\t\tfor (var p in req) {\n \t\t\t\t\tif (req.hasOwnProperty(p)) {\n \t\t\t\t\t\tresult[p] = req[p];\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tresult.toUrl = function(name) {\n \t\t\t\t\treturn toUrl(name, moduleId ? {mid: moduleId} : null);\n \t\t\t\t};\n \t\t\t\tresult.toAbsMid = function(name) {\n \t\t\t\t\treturn toAbsMid(name, moduleId ? {mid: moduleId} : null);\n \t\t\t\t};\n\n \t\t\t\tif (req.undef) {\n \t\t\t\t\tresult.undef = function(mid) {\n \t\t\t\t\t\treq.undef(mid, moduleId);\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction registerAbsMids(absMids) { // eslint-disable-line no-unused-vars\n \t\t\t\tfor (var s in absMids) {\n \t\t\t\t\treq.absMids[s] = absMids[s];\n \t\t\t\t\tif (!req.absMidsById[absMids[s]]) {\n \t\t\t\t\t\treq.absMidsById[absMids[s]] = s;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n\n \t\t\tfunction resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars\n \t\t\t\t// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are\n \t\t\t\t// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression\n \t\t\t\t// using the currently defined features returns a module id, or else undefined.\n\n \t\t\t\tvar has = findModule(\"dojo/has\", null, false);\n \t\t\t\tvar id = has.normalize(expr, function(arg){return arg;});\n \t\t\t\treturn id && __webpack_require__(id) || undefined;\n \t\t\t}\n\n \t\t\tfunction findModule(mid, referenceModule, noInstall, asModuleObj) {\n \t\t\t\tmid = mid.split(\"!\").map(function(segment) {\n \t\t\t\t\tvar isRelative = segment.charAt(0) === '.';\n \t\t\t\t\tif(isRelative && !referenceModule){\n \t\t\t\t\t\treturn segment;\n \t\t\t\t\t}\n \t\t\t\t\treturn toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);\n \t\t\t\t}).join(\"!\");\n \t\t\t\tvar result;\n \t\t\t\tif (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {\n \t\t\t\t\tif (noInstall) {\n \t\t\t\t\t\tvar module = installedModules[req.absMids[mid]];\n \t\t\t\t\t\tresult = module && module.l && (asModuleObj ? module : module.exports);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tresult = __webpack_require__(req.absMids[mid]);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (!result) {\n \t\t\t\t\tthrow new Error('Module not found: ' + mid);\n \t\t\t\t}\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars\n \t\t\t\tvar result = {i:webpackModule.i};\n \t\t\t\tvar id = req.absMidsById[webpackModule.i];\n \t\t\t\tif (id) {\n \t\t\t\t\tresult.id = id;\n \t\t\t\t}\n \t\t\t\tObject.defineProperty(result, \"exports\", {\n \t\t\t\t\tget: function() { return webpackModule.exports;},\n \t\t\t\t\tset: function(value) {webpackModule.exports = value;},\n \t\t\t\t\tenumerable: true,\n \t\t\t\t\tconfigurable: true\n \t\t\t\t});\n \t\t\t\treturn result;\n \t\t\t}\n\n \t\t\tfunction contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow\n \t\t\t\tvar type = ({}.toString).call(a1);\n \t\t\t\tif (type === '[object String]') {\n \t\t\t\t\t// a3 is passed by require calls injected into dependency arrays for dependencies specified\n \t\t\t\t\t// as identifiers (vs. string literals).\n \t\t\t\t\tvar noInstall = !(a3 === false);\n \t\t\t\t\tvar m = findModule(a1, referenceModule, noInstall);\n \t\t\t\t\tif (typeof m === 'object' && m.__DOJO_WEBPACK_DEFINE_PROMISE__) {\n \t\t\t\t\t\tthrow new Error('Module not found: ' + a1);\n \t\t\t\t\t}\n \t\t\t\t\treturn m;\n \t\t\t\t} else if (type === '[object Object]') {\n \t\t\t\t\tthrow new Error('Require config is not supported by WebPack');\n \t\t\t\t}\n \t\t\t\tif (type === '[object Array]') {\n \t\t\t\t\tvar modules = [], callback = a2, errors = [];\n \t\t\t\t\ta1.forEach(function (mid) {\n \t\t\t\t\t\ttry {\n \t\t\t\t\t\t\tmodules.push(findModule(mid, referenceModule));\n \t\t\t\t\t\t} catch (e) {\n \t\t\t\t\t\t\terrors.push({mid: mid, error: e});\n \t\t\t\t\t\t}\n \t\t\t\t\t});\n \t\t\t\t\tif (errors.length === 0) {\n \t\t\t\t\t\tif (callback) {\n \t\t\t\t\t\t\tif (false && isDefinePromise(modules)) { // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\tPromise.all(wrapPromises(modules)).then(function(deps) { // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\t\tcallback.apply(this, unwrapPromises(deps)); // eslint-disable-line no-undef\n \t\t\t\t\t\t\t\t}.bind(this)).catch(function(err){console.error(err);});\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tcallback.apply(this, modules);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tvar error = new Error(\"findModules\");\n \t\t\t\t\t\terror.src = \"dojo-webpack-plugin\";\n \t\t\t\t\t\terror.info = errors;\n \t\t\t\t\t\treq.signal(\"error\", error);\n \t\t\t\t\t}\n \t\t\t\t\treturn req;\n \t\t\t\t} else {\n \t\t\t\t\tthrow new Error('Unsupported require call');\n \t\t\t\t}\n \t\t\t}\n \t\t\treq.toUrl = toUrl;\n \t\t\treq.toAbsMid = toAbsMid;\n \t\t\treq.absMids = {};\n \t\t\treq.absMidsById = [];\n \t\t\treq.async = 1;\n \t\tvar globalObj = this||window;\n \t\tregisterAbsMids({\n \t\t\t// \"C:\\\\Users\\\\BOUALI~1.KAM\\\\AppData\\\\Local\\\\Temp\\\\tmp-25005Jyaz3xCzWdp\\\\dojo\\\\dojo.js\" = 18\n \t\t});\n\n \t\tglobalObj.require = req;\n \t\t\t(this||window)[\"webpackJsonpareactgis\"].registerAbsMids = registerAbsMids;\n\n \t\t// expose the Dojo compatibility functions as a properties of __webpack_require__\n \t\tif (__webpack_require__.dj) throw new Error(\"__webpack_require__.dj name collision.\")\n \t\t__webpack_require__.dj = {\n \t\t\tr: req,\n \t\t\tc: createContextRequire,\n \t\t\tm: dojoModuleFromWebpackModule,\n \t\t\th: resolveTernaryHasExpression,\n \t\t};\n \t\tvar loaderScope = {document:globalObj.document};\n \t\tloaderScope.global = loaderScope.window = loaderScope;\n \t\tglobalObj.dojoConfig = globalObj.dojoConfig || {}\n \t\tvar userConfig = mix(globalObj.dojoConfig, ({'baseUrl':'.','map':({'globalize':({'cldr':'cldrjs/dist/cldr','cldr/event':'cldrjs/dist/cldr/event','cldr/supplemental':'cldrjs/dist/cldr/supplemental','cldr/unresolved':'cldrjs/dist/cldr/unresolved'})}),'async':true,'has':({'config-deferredInstrumentation':1,'dojo-config-api':0,'esri-promise-compatibility':1,'esri-webpack':1})}));\n \t\tvar defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1}),'paths':({}),'pathsMapProg':[],'packs':({'dojo':({'main':'main','name':'dojo','location':'./dojo','lib':'.'}),'dijit':({'main':'main','name':'dijit','location':'./dijit','lib':'.'}),'dojox':({'main':'main','name':'dojox','location':'./dojox','lib':'.'}),'esri':({'main':'kernel','name':'esri','location':'./arcgis-js-api'}),'@dojo':({'main':'main','name':'@dojo','location':'./@dojo','lib':'.'}),'cldrjs':({'main':'dist/cldr','name':'cldrjs','location':'./cldrjs'}),'globalize':({'main':'dist/globalize','name':'globalize','location':'./globalize'}),'tslib':({'main':'tslib','name':'tslib','location':'./tslib'}),'moment':({'main':'main','name':'moment','location':'./moment','lib':'.'}),'dstore':({'main':'main','name':'dstore','location':'./dojo-dstore','lib':'.'}),'maquette':({'main':'dist/maquette.umd','name':'maquette','location':'./maquette','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/polyfills/\") > -1 ||\n \t\t              (mid.indexOf(\"/dist/\") > -1 &&\n \t\t                filename.indexOf(\".umd.js\") === -1)\n \t\t            );\n \t\t          })})}),'maquette-css-transitions':({'main':'dist/maquette-css-transitions.umd','name':'maquette-css-transitions','location':'./maquette-css-transitions','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/dist/\") > -1 && filename.indexOf(\".umd.js\") === -1\n \t\t            );\n \t\t          })})}),'maquette-jsx':({'main':'dist/maquette-jsx.umd','name':'maquette-jsx','location':'./maquette-jsx','resourceTags':({'miniExclude':(function(filename, mid) {\n \t\t            return (\n \t\t              mid.indexOf(\"/dist/\") > -1 && filename.indexOf(\".umd.js\") === -1\n \t\t            );\n \t\t          })})})}),'aliases':[],'mapProgs':[['globalize',[['cldr/supplemental','cldrjs/dist/cldr/supplemental',/^cldr\\/supplemental(\\/|$)/,17],['cldr/unresolved','cldrjs/dist/cldr/unresolved',/^cldr\\/unresolved(\\/|$)/,15],['cldr/event','cldrjs/dist/cldr/event',/^cldr\\/event(\\/|$)/,10],['cldr','cldrjs/dist/cldr',/^cldr(\\/|$)/,4]],/^globalize(\\/|$)/,9]],'cacheBust':undefined,'modules':({}),'cache':({})});\n \t\tvar dojoLoader = __webpack_require__(18);\n \t\tdojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);\n \t\tloaderScope.require.baseUrl = \"./\";\n \t\tObject.keys(loaderScope.require.packs).forEach(function(key) {\n \t\t\tvar pkg = loaderScope.require.packs[key];\n \t\t\tif ((/(^\\/)|(\\:)/.test(pkg.main)\t// main path is absolute\n \t\t\t    || pkg.main.split('/').reduce(function(acc, pathComp) {\n \t\t\t\t\t\tif (acc < 0 || pathComp === '.') return acc;\n \t\t\t\t\t\treturn (pathComp === '..' ? --acc : ++acc);\n \t\t\t\t\t}, 0) <= 0) // main path is outside package\n \t\t\t\t\t&& typeof pkg.realMain === 'undefined'\t// hasn't already been adjusted\n \t\t\t) {\n \t\t\t\tpkg.realMain = pkg.main;\n \t\t\t\tpkg.main = '';\n \t\t\t}\n \t\t});\n \t\tfunction toAbsMid(name, referenceModule) {\n \t\t\tvar absMid = loaderScope.require.originalToAbsMid(name, referenceModule);\n \t\t\tif (absMid.indexOf('/') === absMid.length-1) {\n \t\t\t\tvar pkgName = absMid.substring(0, absMid.length-1);\n \t\t\t\tvar pkg = loaderScope.require.packs[pkgName];\n \t\t\t\tif (pkg && pkg.realMain) {\n \t\t\t\t\tabsMid = pkgName;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn absMid;\n \t\t}\n \t\tfunction toUrl(name, referenceModule) {\n \t\t\tvar url = loaderScope.require.originalToUrl(name, referenceModule);\n \t\t\tvar pkg = loaderScope.require.packs[name];\n \t\t\tif (pkg && pkg.realMain) {\n \t\t\t\tvar parts = url.split('?');\n \t\t\t\tif (/(^\\/)|(\\:)/.test(pkg.realMain)) {\n \t\t\t\t\t// absolute URL\n \t\t\t\t\tparts[0] = pkg.realMain;\n \t\t\t\t} else {\n \t\t\t\t\t// relative URL\n \t\t\t\t\tparts[0] = parts[0] + '/' + pkg.realMain;\n \t\t\t\t}\n \t\t\t\turl = parts.join('?');\n \t\t\t}\n \t\t\treturn url;\n \t\t}\n \t\tloaderScope.require.originalToAbsMid = loaderScope.require.toAbsMid;\n \t\tloaderScope.require.originalToUrl = loaderScope.require.toUrl;\n \t\tloaderScope.require.toAbsMid = toAbsMid;\n \t\tloaderScope.require.toUrl = toUrl;\n \t\t['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})\n \t})(); /* End undefined extensions */\n\n \t// run deferred modules from other chunks\n \tcheckDeferredModules();\n","module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = \"1.14.2\"; (function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\t//\n\t// The \"foreign-loader\" has condition is defined if another loader is being used (e.g. webpack) and this code is only\n\t// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and \n\t// require.toAbsMid are supported.  The require and define functions are not supported.\n\n\t// define global\n\tvar globalObject = (function(){\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\n\t\t\t// global spec defines a reference to the global object called 'global'\n\t\t\t// https://github.com/tc39/proposal-global\n\t\t\t// `global` is also defined in NodeJS\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof window !== 'undefined') {\n\t\t\t// window is defined in browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// self is defined in WebWorkers\n\t\t\treturn self;\n\t\t}\n\t\treturn this;\n\t})();\n\n\t// define a minimal library to help build the loader\n\tvar noop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = globalObject,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\tif (isFunction(userConfig)) {\n\t\tuserConfig = userConfig(globalObject);\n\t}\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\t 0 && has.add(\"host-node\", userConfig.has && \"host-node\" in userConfig.has ?\n\t\tuserConfig.has[\"host-node\"] :\n\t\t(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\tif( 0 ){\n\t\t// fixup the default config for node.js environment\n\t\trequire(\"./_base/configNode.js\").config(defaultConfig);\n\t\t// remember node's require (with respect to baseUrl==dojo's root)\n\t\tdefaultConfig.loaderPatch.nodeRequire = require;\n\t}\n\n\t 0 && has.add(\"host-rhino\", userConfig.has && \"host-rhino\" in userConfig.has ?\n\t\tuserConfig.has[\"host-rhino\"] :\n\t\t(typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\tif( 0 ){\n\t\t// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...\n\t\tfor(var baseUrl = userConfig.baseUrl || \".\", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){\n\t\t\targ = (rhinoArgs[i++] + \"\").split(\"=\");\n\t\t\tif(arg[0] == \"baseUrl\"){\n\t\t\t\tbaseUrl = arg[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tload(baseUrl + \"/_base/configRhino.js\");\n\t\trhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);\n\t}\n\n\t 0 && has.add(\"host-webworker\", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));\n\tif( 0 ){\n\t\tmix(defaultConfig.hasCache, {\n\t\t\t\"host-browser\": 0,\n\t\t\t\"dom\": 0,\n\t\t\t\"dojo-dom-ready-api\": 0,\n\t\t\t\"dojo-sniff\": 0,\n\t\t\t\"dojo-inject-api\": 1,\n\t\t\t\"host-webworker\": 1,\n\t\t\t\"dojo-guarantee-console\": 0 // console is immutable in FF30+, see https://bugs.dojotoolkit.org/ticket/18100\n\t\t});\n\n\t\tdefaultConfig.loaderPatch = {\n\t\t\tinjectUrl: function(url, callback){\n\t\t\t\t// TODO:\n\t\t\t\t//\t\tThis is not async, nor can it be in Webworkers.  It could be made better by passing\n\t\t\t\t//\t\tthe entire require array into importScripts at.  This way the scripts are loaded in\n\t\t\t\t//\t\tasync mode; even if the callbacks are ran in sync.  It is not a major issue as webworkers\n\t\t\t\t//\t\ttend to be long running where initial startup is not a major factor.\n\n\t\t\t\ttry{\n\t\t\t\t\timportScripts(url);\n\t\t\t\t\tcallback();\n\t\t\t\t}catch(e){\n\t\t\t\t\tconsole.info(\"failed to load resource (\" + url + \")\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar requested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif( 0 ){\n\t\t// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code\n\t\trequested = \"requested\";\n\t\tarrived = \"arrived\";\n\t\tnonmodule = \"not-a-module\";\n\t\texecuting = \"executing\";\n\t\texecuted = \"executed\";\n\t}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif( 0 ){\n\t\treq.isXdUrl = noop;\n\n\t\treq.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){\n\t\t\t// the first dojo/_base/loader loaded gets to define these variables; they are designed to work\n\t\t\t// in the presence of zero to many mapped dojo/_base/loaders\n\t\t\tif(!dojoRequirePlugin){\n\t\t\t\tdojoRequirePlugin = dojoRequirePlugin_;\n\t\t\t\tcheckDojoRequirePlugin = checkDojoRequirePlugin_;\n\t\t\t\ttransformToAmd = transformToAmd_;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsync:sync,\n\t\t\t\trequested:requested,\n\t\t\t\tarrived:arrived,\n\t\t\t\tnonmodule:nonmodule,\n\t\t\t\texecuting:executing,\n\t\t\t\texecuted:executed,\n\t\t\t\tsyncExecStack:syncExecStack,\n\t\t\t\tmodules:modules,\n\t\t\t\texecQ:execQ,\n\t\t\t\tgetModule:getModule,\n\t\t\t\tinjectModule:injectModule,\n\t\t\t\tsetArrived:setArrived,\n\t\t\t\tsignal:signal,\n\t\t\t\tfinishExec:finishExec,\n\t\t\t\texecModule:execModule,\n\t\t\t\tdojoRequirePlugin:dojoRequirePlugin,\n\t\t\t\tgetLegacyMode:function(){return legacyMode;},\n\t\t\t\tguardCheckComplete:guardCheckComplete\n\t\t\t};\n\t\t};\n\n\t\tif( 0  ||  0 ){\n\t\t\t// in legacy sync mode, the loader needs a minimal XHR library\n\n\t\t\tvar locationProtocol = location.protocol,\n\t\t\t\tlocationHost = location.host;\n\t\t\treq.isXdUrl = function(url){\n\t\t\t\tif(/^\\./.test(url)){\n\t\t\t\t\t// begins with a dot is always relative to page URL; therefore not xdomain\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(/^\\/\\//.test(url)){\n\t\t\t\t\t// for v1.6- backcompat, url starting with // indicates xdomain\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// get protocol and host\n\t\t\t\t// \\/+ takes care of the typical file protocol that looks like file:///drive/path/to/file\n\t\t\t\t// locationHost is falsy if file protocol => if locationProtocol matches and is \"file:\", || will return false\n\t\t\t\tvar match = url.match(/^([^\\/\\:]+\\:)\\/+([^\\/]+)/);\n\t\t\t\treturn match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));\n\t\t\t};\n\n\n\t\t\t// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config\n\t\t\t 1 || has.add(\"dojo-xhr-factory\", 1);\n\t\t\t 0 && has.add(\"dojo-force-activex-xhr\",  1  && !doc.addEventListener && window.location.protocol == \"file:\");\n\t\t\thas.add(\"native-xhr\", typeof XMLHttpRequest != \"undefined\");\n\t\t\tif(has(\"native-xhr\") && ! 0 ){\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new XMLHttpRequest();\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// if in the browser an old IE; find an xhr\n\t\t\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\t\t\tif(new ActiveXObject(progid)){\n\t\t\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch; we're just trying to find a good ActiveX progid\n\t\t\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t};\n\t\t\t}\n\t\t\treq.getXhr = getXhr;\n\n\t\t\thas.add(\"dojo-gettext-api\", 1);\n\t\t\treq.getText = function(url, async, onLoad){\n\t\t\t\tvar xhr = getXhr();\n\t\t\t\txhr.open('GET', fixupUrl(url), false);\n\t\t\t\txhr.send(null);\n\t\t\t\tif(xhr.status == 200 || (!location.host && !xhr.status)){\n\t\t\t\t\tif(onLoad){\n\t\t\t\t\t\tonLoad(xhr.responseText, async);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthrow makeError(\"xhrFailed\", xhr.status);\n\t\t\t\t}\n\t\t\t\treturn xhr.responseText;\n\t\t\t};\n\t\t}\n\t}else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =   1  ?\n\t\t// noop eval if there are csp restrictions\n\t\tfunction(){} :\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tnew Function('return eval(arguments[0]);');\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n//# sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif( 0 ){\n\t\tif (! 1 ) {\n\t\t\tvar consumePendingCacheInsert = function(referenceModule, clear){\n\t\t\t\t\tclear = clear !== false;\n\t\t\t\t\tvar p, item, match, now, m;\n\t\t\t\t\tfor(p in pendingCacheInsert){\n\t\t\t\t\t\titem = pendingCacheInsert[p];\n\t\t\t\t\t\tmatch = p.match(/^url\\:(.+)/);\n\t\t\t\t\t\tif(match){\n\t\t\t\t\t\t\tcache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;\n\t\t\t\t\t\t}else if(p==\"*now\"){\n\t\t\t\t\t\t\tnow = item;\n\t\t\t\t\t\t}else if(p!=\"*noref\"){\n\t\t\t\t\t\t\tm = getModuleInfo(p, referenceModule, true);\n\t\t\t\t\t\t\tcache[m.mid] = cache[urlKeyPrefix + m.url] = item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(now){\n\t\t\t\t\t\tnow(createRequire(referenceModule));\n\t\t\t\t\t}\n\t\t\t\t\tif(clear){\n\t\t\t\t\t\tpendingCacheInsert = {};\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t}\n\t\tvar escapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevant to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tcomputeAliases = function(config, dest){\n\t\t\t\tforEach(config, function(pair){\n\t\t\t\t\t// take a fixed-up copy...\n\t\t\t\t\tdest.push([isString(pair[0]) ? new RegExp(\"^\" + escapeString(pair[0]) + \"$\") : pair[0], pair[1]]);\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is deprecated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consumed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif( 0  && p==\"async\"){\n\t\t\t\t\t\t// falsy or \"sync\" => legacy sync loader\n\t\t\t\t\t\t// \"xd\" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)\n\t\t\t\t\t\t// \"legacyAsync\" => permanently in \"xd\" by choice\n\t\t\t\t\t\t// \"debugAtAllCosts\" => trying to load everything via script injection (not implemented)\n\t\t\t\t\t\t// otherwise, must be truthy => AMD\n\t\t\t\t\t\t// legacyMode: sync | legacyAsync | xd | false\n\t\t\t\t\t\tvar mode = config[p];\n\t\t\t\t\t\treq.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));\n\t\t\t\t\t\treq.async = !legacyMode;\n\t\t\t\t\t}\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is deprecated; remove in 2.0\n\t\t\t\tfor(var baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tcomputeAliases(config.aliases, aliases);\n\n\t\t\t\tif (! 1 ) {\n\t\t\t\t\tif(booting){\n\t\t\t\t\t\tdelayedModuleConfig.push({config:config.config});\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(p in config.config){\n\t\t\t\t\t\t\tvar module = getModule(p, referenceModule);\n\t\t\t\t\t\t\tmodule.config = mix(module.config || {}, config.config[p]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// push in any new cache values\n\t\t\t\t\tif(config.cache){\n\t\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\t\tpendingCacheInsert = config.cache;\n\t\t\t\t\t\t//inject now all depencies so cache is available for mapped module\n\t\t\t\t\t\tconsumePendingCacheInsert(0, !!config.cache[\"*noref\"]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif( 0  ||  0 ){\n\t\t\t// the sniff regex looks for a src attribute ending in dojo.js, optionally preceded with a path.\n\t\t\t// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the\n\t\t\t// dojo location on CDN deployments and baseUrl when either/both of these are not provided\n\t\t\t// explicitly in the config data; this is the 1.6- behavior.\n\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript, dojoDir, src, match;\n\t\t\twhile(i < scripts.length){\n\t\t\t\tscript = scripts[i++];\n\t\t\t\tif((src = script.getAttribute(\"src\")) && (match = src.match(/(((.*)\\/)|^)dojo\\.js(\\W|$)/i))){\n\t\t\t\t\t// sniff dojoDir and baseUrl\n\t\t\t\t\tdojoDir = match[3] || \"\";\n\t\t\t\t\tdefaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff configuration on attribute in script element\n\t\t\t\tif((src = (script.getAttribute(\"data-dojo-config\") || script.getAttribute(\"djConfig\")))){\n\t\t\t\t\tdojoSniffConfig = req.eval(\"({ \" + src + \" })\", \"data-dojo-config\");\n\n\t\t\t\t\t// remember an insertPointSibling\n\t\t\t\t\tinsertPointSibling = script;\n\t\t\t\t}\n\n\t\t\t\t// sniff requirejs attribute\n\t\t\t\tif( 0 ){\n\t\t\t\t\tif((src = script.getAttribute(\"data-main\"))){\n\t\t\t\t\t\tdojoSniffConfig.deps = dojoSniffConfig.deps || [src];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( 0 ){\n\t\t\t// pass down doh.testConfig from parent as if it were a data-dojo-config\n\t\t\ttry{\n\t\t\t\tif(window.parent != window && window.parent.require){\n\t\t\t\t\tvar doh = window.parent.require(\"doh\");\n\t\t\t\t\tdoh && mix(dojoSniffConfig, doh.testConfig);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif( 0 ){\n\t\t\tpacks.dojo.location = dojoDir;\n\t\t\tif(dojoDir){\n\t\t\t\tdojoDir += \"/\";\n\t\t\t}\n\t\t\tpacks.dijit.location = dojoDir + \"../dijit/\";\n\t\t\tpacks.dojox.location = dojoDir + \"../dojox/\";\n\t\t}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tmapProgs = defaultConfig.mapProgs;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif (! 1 ) {\n\t\tif( 0 ){\n\t\t\treq.combo = req.combo || {add:noop};\n\t\t\tvar comboPending = 0,\n\t\t\t\tcombosPending = [],\n\t\t\t\tcomboPendingTimer = null;\n\t\t}\n\t\t\n\n\t\t// build the loader machinery iaw configuration, including has feature tests\n\t\tvar injectDependencies = function(module){\n\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\tforEach(module.deps, injectModule);\n\t\t\t\t\tif( 0  && comboPending && !comboPendingTimer){\n\t\t\t\t\t\tcomboPendingTimer = setTimeout(function() {\n\t\t\t\t\t\t\tcomboPending = 0;\n\t\t\t\t\t\t\tcomboPendingTimer = null;\n\t\t\t\t\t\t\treq.combo.done(function(mids, url) {\n\t\t\t\t\t\t\t\tvar onLoadCallback= function(){\n\t\t\t\t\t\t\t\t\t// defQ is a vector of module definitions 1-to-1, onto mids\n\t\t\t\t\t\t\t\t\trunDefQ(0, mids);\n\t\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcombosPending.push(mids);\n\t\t\t\t\t\t\t\tinjectingModule = mids;\n\t\t\t\t\t\t\t\treq.injectUrl(url, onLoadCallback, mids);\n\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t}, req);\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\n\t\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\t\tvar module, syntheticMid;\n\t\t\t\tif(isString(a1)){\n\t\t\t\t\t// signature is (moduleId)\n\t\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\t\tif(module && module.executed){\n\t\t\t\t\t\treturn module.result;\n\t\t\t\t\t}\n\t\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t\t}\n\t\t\t\tif(!isArray(a1)){\n\t\t\t\t\t// a1 is a configuration\n\t\t\t\t\tconfig(a1, 0, referenceModule);\n\n\t\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\t\ta1 = a2;\n\t\t\t\t\ta2 = a3;\n\t\t\t\t}\n\t\t\t\tif(isArray(a1)){\n\t\t\t\t\t// signature is (requestList [,callback])\n\t\t\t\t\tif(!a1.length){\n\t\t\t\t\t\ta2 && a2();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\t\t\tinjected: arrived,\n\t\t\t\t\t\t\tdeps: deps,\n\t\t\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\t\t\trequire: referenceModule ? referenceModule.require : req,\n\t\t\t\t\t\t\tgc: 1 //garbage collect\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t\t\t// try to immediately execute\n\t\t\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\t\t\tvar strict = checkCompleteGuard && legacyMode!=sync;\n\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\texecModule(module, strict);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif(!module.executed){\n\t\t\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\t\t\texecQ.push(module);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contextRequire;\n\t\t\t},\n\n\t\t\tcreateRequire = function(module){\n\t\t\t\tif(!module){\n\t\t\t\t\treturn req;\n\t\t\t\t}\n\t\t\t\tvar result = module.require;\n\t\t\t\tif(!result){\n\t\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t\t};\n\t\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\t\tresult.module = module;\n\t\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t\t};\n\t\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t\t};\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tresult.undef = function(mid){\n\t\t\t\t\t\t\treq.undef(mid, module);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tresult.syncLoadNls = function(mid){\n\t\t\t\t\t\t\tvar nlsModuleInfo = getModuleInfo(mid, module),\n\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\tif(!nlsModule || !nlsModule.executed){\n\t\t\t\t\t\t\t\tcached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];\n\t\t\t\t\t\t\t\tif(cached){\n\t\t\t\t\t\t\t\t\tevalModuleText(cached);\n\t\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn nlsModule && nlsModule.executed && nlsModule.result;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\n\t\t  execQ =\n\t\t\t\t// The list of modules that need to be evaluated.\n\t\t\t\t[],\n\n\t\t\tdefQ =\n\t\t\t\t// The queue of define arguments sent to loader.\n\t\t\t\t[],\n\n\t\t\twaiting =\n\t\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t\t{},\n\n\t\t\tsetRequested = function(module){\n\t\t\t\tmodule.injected = requested;\n\t\t\t\twaiting[module.mid] = 1;\n\t\t\t\tif(module.url){\n\t\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t\t}\n\t\t\t\tstartTimer();\n\t\t\t},\n\n\t\t\tsetArrived = function(module){\n\t\t\t\tmodule.injected = arrived;\n\t\t\t\tdelete waiting[module.mid];\n\t\t\t\tif(module.url){\n\t\t\t\t\tdelete waiting[module.url];\n\t\t\t\t}\n\t\t\t\tif(isEmpty(waiting)){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\t 0  && legacyMode==xd && (legacyMode = sync);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\texecComplete = req.idle =\n\t\t\t\t// says the loader has completed (or not) its work\n\t\t\t\tfunction(){\n\t\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t\t};\n\t}\n\n\tvar runMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif( 0 ){\n\t\t\t\tvar xd= req.isXdUrl(url);\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};\n\t\t\t}else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(!fromPendingCache && !isRelative && mapProgs.star){\n\t\t\t\t\tmapItem = runMapProg(mid, mapProgs.star[1]);\n\t\t\t\t}\n\t\t\t\tif(!mapItem && referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\t\t\t\t}\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + \"/\" + midInPackage;\n\t\t\t}else if( 0 ){\n\t\t\t\turl = \"../\" + mid;\n\t\t\t}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);\n\t\t};\n\n\tif (! 1 ) {\n\t\tvar resolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t\t},\n\n\t\t\tdynamicPluginUidGenerator = 0,\n\n\t\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\t\tvar match, plugin, prid, result;\n\t\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\t\tif(match){\n\t\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\t\tif( 0  && legacyMode == sync && !plugin.executed){\n\t\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t\t\tif(plugin.injected===arrived && !plugin.executed){\n\t\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\t\texecModule(plugin);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(plugin.executed){\n\t\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// we are in xdomain mode for some reason\n\t\t\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\t\tif(plugin.load){\n\t\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tprid = match[2];\n\t\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t\t}\n\t\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t\t}else{\n\t\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t\t}\n\t\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t\t};\n\t}\n\n\tvar toAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t};\n\n\tif (! 1 ) {\n\t\tvar nonModuleProps = {\n\t\t\t\tinjected: arrived,\n\t\t\t\texecuted: executed,\n\t\t\t\tdef: nonmodule,\n\t\t\t\tresult: nonmodule\n\t\t\t},\n\n\t\t\tmakeCjs = function(mid){\n\t\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t\t},\n\n\t\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\t\trunFactory = function(module, args){\n\t\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\t\tvar factory = module.def,\n\t\t\t\t\tresult;\n\t\t\t\t 0  && syncExecStack.unshift(module);\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, module.result = makeError(\"factoryThrew\", [module, e]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t}\n\t\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\t\t 0  && syncExecStack.shift(module);\n\t\t\t},\n\n\t\t\tabortExec = {},\n\n\t\t\tdefOrder = 0,\n\n\t\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\t\tvar plugin = pluginModule.result;\n\t\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\t\tpluginModule.load = plugin.load;\n\t\t\t\treturn pluginModule;\n\t\t\t},\n\n\t\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\t\tvar map = {};\n\t\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\t\tvar prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\t\tif(!modules[mid] || !modules[mid].injected /*for require.undef*/){\n\t\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t\t});\n\t\t\t\tplugin.loadQ = 0;\n\n\t\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\t\tvar substituteModules = function(module){\n\t\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\t\tif(replacement){\n\t\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfor(var p in modules){\n\t\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t\t}\n\t\t\t\tforEach(execQ, substituteModules);\n\t\t\t},\n\n\t\t\tfinishExec = function(module){\n\t\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\t\tmodule.executed = executed;\n\t\t\t\tmodule.defOrder = defOrder++;\n\t\t\t\t 0  && forEach(module.provides, function(cb){ cb(); });\n\t\t\t\tif(module.loadQ){\n\t\t\t\t\t// the module was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t\t}\n\t\t\t\t// remove all occurrences of this module from the execQ\n\t\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// delete references to synthetic modules\n\t\t\t\tif (/^require\\*/.test(module.mid)) {\n\t\t\t\t\tdelete modules[module.mid];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcircleTrace = [],\n\n\t\t\texecModule = function(module, strict){\n\t\t\t\t// run the dependency vector, then run the factory for module\n\t\t\t\tif(module.executed === executing){\n\t\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(module.mid).join(\"->\")]);\n\t\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t\t}\n\t\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\t\tif(!module.executed){\n\t\t\t\t\tif(!module.def){\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\tvar mid = module.mid,\n\t\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\t\targ, argResult,\n\t\t\t\t\t\targs = [],\n\t\t\t\t\t\ti = 0;\n\n\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\tcircleTrace.push(mid);\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"exec\", circleTrace.length, mid]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t\t// the pre-made cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\t\tmodule.executed = executing;\n\t\t\t\t\twhile((arg = deps[i++])){\n\t\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\t\t 0  && circleTrace.pop();\n\t\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs.push(argResult);\n\t\t\t\t\t}\n\t\t\t\t\trunFactory(module, args);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t 0  && circleTrace.pop();\n\t\t\t\t}\n\t\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\t\treturn module.result;\n\t\t\t},\n\n\n\t\t\tcheckCompleteGuard = 0,\n\n\t\t\tguardCheckComplete = function(proc){\n\t\t\t\ttry{\n\t\t\t\t\tcheckCompleteGuard++;\n\t\t\t\t\tproc();\n\t\t\t\t}catch(e){\n\t\t\t\t\t// https://bugs.dojotoolkit.org/ticket/16617\n\t\t\t\t\tthrow e;\n\t\t\t\t}finally{\n\t\t\t\t\tcheckCompleteGuard--;\n\t\t\t\t}\n\t\t\t\tif(execComplete()){\n\t\t\t\t\tsignal(\"idle\", []);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcheckComplete = function(){\n\t\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\t\tif(checkCompleteGuard){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\t\t\tmodule = execQ[i];\n\t\t\t\t\t\texecModule(module);\n\t\t\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar fixupUrl= typeof userConfig.fixupUrl == \"function\" ? userConfig.fixupUrl : function(url){\n\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t};\n\n\n\n\tif( 0 ){\n\t\treq.undef = function(moduleId, referenceModule){\n\t\t\t// In order to reload a module, it must be undefined (this routine) and then re-requested.\n\t\t\t// This is useful for testing frameworks (at least).\n\t\t\tvar module = getModule(moduleId, referenceModule);\n\t\t\tsetArrived(module);\n\t\t\tmix(module, {def:0, executed:0, injected:0, node:0, load:0});\n\t\t};\n\t}\n\n\tif( false ){\n\t\tif( 0 ===undefined){\n\t\t\t 0 && has.add(\"dojo-loader-eval-hint-url\", 1);\n\t\t}\n\n\t\tvar injectPlugin = function(\n\t\t\t\tmodule\n\t\t\t){\n\t\t\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\t\t\tvar plugin = module.plugin;\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\tvar onLoad = function(def){\n\t\t\t\t\t\tmodule.result = def;\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t}else if(plugin.loadQ){\n\t\t\t\t\tplugin.loadQ.push(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\t\t\tplugin.loadQ = [module];\n\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for IE, injecting a module may result in a recursive execution if the module is in the cache\n\n\t\t\tcached = 0,\n\n\t\t\tinjectingModule = 0,\n\n\t\t\tinjectingCachedModule = 0,\n\n\t\t\tevalModuleText = function(text, module){\n\t\t\t\t// see def() for the injectingCachedModule bracket; it simply causes a short, safe circuit\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttext = text.replace(/([\"'])use strict\\1/g, '');\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 1;\n\t\t\t\tif( 0 ){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.eval(text,  0  ? module.url : module.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, makeError(\"evalModuleThrew\", module));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treq.eval(text,  0  ? module.url : module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 0;\n\t\t\t},\n\n\t\t\tinjectModule = function(module){\n\t\t\t\t// Inject the module. In the browser environment, this means appending a script element into\n\t\t\t\t// the document; in other environments, it means loading a file.\n\t\t\t\t//\n\t\t\t\t// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.\n\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\turl = module.url;\n\t\t\t\tif(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetRequested(module);\n\n\t\t\t\tif( 0 ){\n\t\t\t\t\tvar viaCombo = 0;\n\t\t\t\t\tif(module.plugin && module.plugin.isCombo){\n\t\t\t\t\t\t// a combo plugin; therefore, must be handled by combo service\n\t\t\t\t\t\t// the prid should have already been converted to a URL (if required by the plugin) during\n\t\t\t\t\t\t// the normalize process; in any event, there is no way for the loader to know how to\n\t\t\t\t\t\t// to the conversion; therefore the third argument is zero\n\t\t\t\t\t\treq.combo.add(module.plugin.mid, module.prid, 0, req);\n\t\t\t\t\t\tviaCombo = 1;\n\t\t\t\t\t}else if(!module.plugin){\n\t\t\t\t\t\tviaCombo = req.combo.add(0, module.mid, module.url, req);\n\t\t\t\t\t}\n\t\t\t\t\tif(viaCombo){\n\t\t\t\t\t\tcomboPending= 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(module.plugin){\n\t\t\t\t\tinjectPlugin(module);\n\t\t\t\t\treturn;\n\t\t\t\t} // else a normal module (not a plugin)\n\n\n\t\t\t\tvar onLoadCallback = function(){\n\t\t\t\t\trunDefQ(module);\n\t\t\t\t\tif(module.injected !== arrived){\n\t\t\t\t\t\t// the script that contained the module arrived and has been executed yet\n\t\t\t\t\t\t// nothing was added to the defQ (so it wasn't an AMD module) and the module\n\t\t\t\t\t\t// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);\n\t\t\t\t\t\t// therefore, it must not have been a module; adjust state accordingly\n\t\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\t\tsignal(error, makeError(\"noDefine\", module));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tmix(module, nonModuleProps);\n\t\t\t\t\t\treq.trace(\"loader-define-nonmodule\", [module.url]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif( 0  && legacyMode){\n\t\t\t\t\t\t// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;\n\t\t\t\t\t\t// but, if xd loading, then don't call checkComplete until out of the current sync traversal\n\t\t\t\t\t\t// in order to preserve order of execution of the dojo.required modules\n\t\t\t\t\t\t!syncExecStack.length && checkComplete();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcached = cache[mid] || cache[urlKeyPrefix + module.url];\n\t\t\t\tif(cached){\n\t\t\t\t\treq.trace(\"loader-inject\", [\"cache\", module.mid, url]);\n\t\t\t\t\tevalModuleText(cached, module);\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif( 0  && legacyMode){\n\t\t\t\t\tif(module.isXd){\n\t\t\t\t\t\t// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}\n\t\t\t\t\t\tlegacyMode==sync && (legacyMode = xd);\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else if(module.isAmd && legacyMode!=sync){\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain\n\t\t\t\t\t\tvar xhrCallback = function(text){\n\t\t\t\t\t\t\tif(legacyMode==sync){\n\t\t\t\t\t\t\t\t// the top of syncExecStack gives the current synchronously executing module; the loader needs\n\t\t\t\t\t\t\t\t// to know this if it has to switch to async loading in the middle of evaluating a legacy module\n\t\t\t\t\t\t\t\t// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain\n\t\t\t\t\t\t\t\t// (using unshift/shift because there is no back() methods for Javascript arrays)\n\t\t\t\t\t\t\t\tsyncExecStack.unshift(module);\n\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\tsyncExecStack.shift();\n\n\t\t\t\t\t\t\t\t// maybe the module was an AMD module\n\t\t\t\t\t\t\t\trunDefQ(module);\n\n\t\t\t\t\t\t\t\t// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing\n\t\t\t\t\t\t\t\tif(!module.cjs){\n\t\t\t\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(module.finish){\n\t\t\t\t\t\t\t\t\t// while synchronously evaluating this module, dojo.require was applied referencing a module\n\t\t\t\t\t\t\t\t\t// that had to be loaded async; therefore, the loader stopped answering all dojo.require\n\t\t\t\t\t\t\t\t\t// requests so they could be answered completely in the correct sequence; module.finish gives\n\t\t\t\t\t\t\t\t\t// the list of dojo.requires that must be re-applied once all target modules are available;\n\t\t\t\t\t\t\t\t\t// make a synthetic module to execute the dojo.require's in the correct order\n\n\t\t\t\t\t\t\t\t\t// compute a guaranteed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module\n\t\t\t\t\t\t\t\t\t// TODO: can we just leave the module.finish...what's it hurting?\n\t\t\t\t\t\t\t\t\tvar finishMid = mid + \"*finish\",\n\t\t\t\t\t\t\t\t\t\tfinish = module.finish;\n\t\t\t\t\t\t\t\t\tdelete module.finish;\n\n\t\t\t\t\t\t\t\t\tdef(finishMid, [\"dojo\", (\"dojo/require!\" + finish.join(\",\")).replace(/\\./g, \"/\")], function(dojo){\n\t\t\t\t\t\t\t\t\t\tforEach(finish, function(mid){ dojo.require(mid); });\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t// unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\t\t\t\t\texecQ.unshift(getModule(finishMid));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttext = transformToAmd(module, text);\n\t\t\t\t\t\t\t\tif(text){\n\t\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected\n\t\t\t\t\t\t\t\t\t// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)\n\t\t\t\t\t\t\t\t\tinjectingModule = module;\n\t\t\t\t\t\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treq.trace(\"loader-inject\", [\"xhr\", module.mid, url, legacyMode!=sync]);\n\t\t\t\t\t\tif( 0 ){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tsignal(error, makeError(\"xhrInjectFailed\", [module, e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} // else async mode or fell through in xdomain loading mode; either way, load by script injection\n\t\t\t\treq.trace(\"loader-inject\", [\"script\", module.mid, url]);\n\t\t\t\tinjectingModule = module;\n\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\tinjectingModule = 0;\n\t\t\t},\n\n\t\t\tdefineModule = function(module, deps, def){\n\t\t\t\treq.trace(\"loader-define-module\", [module.mid, deps]);\n\n\t\t\t\tif( 0  && module.plugin && module.plugin.isCombo){\n\t\t\t\t\t// the module is a plugin resource loaded by the combo service\n\t\t\t\t\t// note: check for module.plugin should be enough since normal plugin resources should\n\t\t\t\t\t// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders\n\t\t\t\t\tmodule.result = isFunction(def) ? def() : def;\n\t\t\t\t\tsetArrived(module);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\n\t\t\t\tvar mid = module.mid;\n\t\t\t\tif(module.injected === arrived){\n\t\t\t\t\tsignal(error, makeError(\"multipleDefine\", module));\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t\tmix(module, {\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: def,\n\t\t\t\t\tcjs: {\n\t\t\t\t\t\tid: module.mid,\n\t\t\t\t\t\turi: module.url,\n\t\t\t\t\t\texports: (module.result = {}),\n\t\t\t\t\t\tsetExports: function(exports){\n\t\t\t\t\t\t\tmodule.cjs.exports = exports;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfig:function(){\n\t\t\t\t\t\t\treturn module.config;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// resolve deps with respect to this module\n\t\t\t\tfor(var i = 0; deps[i]; i++){\n\t\t\t\t\tdeps[i] = getModule(deps[i], module);\n\t\t\t\t}\n\n\t\t\t\tif( 0  && legacyMode && !waiting[mid]){\n\t\t\t\t\t// the module showed up without being asked for; it was probably in a <script> element\n\t\t\t\t\tinjectDependencies(module);\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t\tsetArrived(module);\n\n\t\t\t\tif(!isFunction(def) && !deps.length){\n\t\t\t\t\tmodule.result = def;\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t},\n\n\t\t\trunDefQ = function(referenceModule, mids){\n\t\t\t\t// defQ is an array of [id, dependencies, factory]\n\t\t\t\t// mids (if any) is a vector of mids given by a combo service\n\t\t\t\tvar definedModules = [],\n\t\t\t\t\tmodule, args;\n\t\t\t\twhile(defQ.length){\n\t\t\t\t\targs = defQ.shift();\n\t\t\t\t\tmids && (args[0]= mids.shift());\n\t\t\t\t\t// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully\n\t\t\t\t\t// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue\n\t\t\t\t\t// TODO: what if no args[0] and no referenceModule\n\t\t\t\t\tmodule = (args[0] && getModule(args[0])) || referenceModule;\n\t\t\t\t\tdefinedModules.push([module, args[1], args[2]]);\n\t\t\t\t}\n\t\t\t\tconsumePendingCacheInsert(referenceModule);\n\t\t\t\tforEach(definedModules, function(args){\n\t\t\t\t\tinjectDependencies(defineModule.apply(null, args));\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif( 0 ){\n\t\t// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.\n\t\tclearTimer = function(){\n\t\t\ttimerId && clearTimeout(timerId);\n\t\t\ttimerId = 0;\n\t\t};\n\n\t\tstartTimer = function(){\n\t\t\tclearTimer();\n\t\t\tif(req.waitms){\n\t\t\t\ttimerId = global.setTimeout(function(){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\tsignal(error, makeError(\"timeout\", waiting));\n\t\t\t\t}, req.waitms);\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( 0 ) {\n\t\t// Test for IE's different way of signaling when scripts finish loading.  Note that according to\n\t\t// http://bugs.dojotoolkit.org/ticket/15096#comment:14, IE9 also needs to follow the\n\t\t// IE specific code path even though it has an addEventListener() method.\n\t\t// Unknown if special path needed on IE10+, which also has a document.attachEvent() method.\n\t\t// Should evaluate to false for Opera and Windows 8 apps, even though they document.attachEvent()\n\t\t//  is defined in both those environments.\n\t\t 0 && has.add(\"ie-event-behavior\", doc.attachEvent && typeof Windows === \"undefined\" &&\n\t\t\t(typeof opera === \"undefined\" || opera.toString() != \"[object Opera]\"));\n\t}\n\n\tif( 0  && ( false  ||  1 )){\n\t\tvar domOn = function(node, eventName, ieEventName, handler){\n\t\t\t\t// Add an event listener to a DOM node using the API appropriate for the current browser;\n\t\t\t\t// return a function that will disconnect the listener.\n\t\t\t\tif(! 0 ){\n\t\t\t\t\tnode.addEventListener(eventName, handler, false);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.removeEventListener(eventName, handler, false);\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tnode.attachEvent(ieEventName, handler);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.detachEvent(ieEventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\twindowOnLoadListener = domOn(window, \"load\", \"onload\", function(){\n\t\t\t\treq.pageLoaded = 1;\n\t\t\t\t// https://bugs.dojotoolkit.org/ticket/16248\n\t\t\t\ttry{\n\t\t\t\t\tdoc.readyState!=\"complete\" && (doc.readyState = \"complete\");\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t\twindowOnLoadListener();\n\t\t\t});\n\n\t\tif( false ){\n\t\t\t// if the loader is on the page, there must be at least one script element\n\t\t\t// getting its parent and then doing insertBefore solves the \"Operation Aborted\"\n\t\t\t// error in IE from appending to a node that isn't properly closed; see\n\t\t\t// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example\n\t\t\t// don't use scripts with type dojo/... since these may be removed; see #15809\n\t\t\t// prefer to use the insertPoint computed during the config sniff in case a script is removed; see #16958\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript;\n\t\t\twhile(!insertPointSibling){\n\t\t\t\tif(!/^dojo/.test((script = scripts[i++]) && script.type)){\n\t\t\t\t\tinsertPointSibling= script;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.injectUrl = function(url, callback, owner){\n\t\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t\t// apply callback upon detecting the script has loaded.\n\n\t\t\t\tvar node = owner.node = doc.createElement(\"script\"),\n\t\t\t\t\tonLoad = function(e){\n\t\t\t\t\t\te = e || window.event;\n\t\t\t\t\t\tvar node = e.target || e.srcElement;\n\t\t\t\t\t\tif(e.type === \"load\" || /complete|loaded/.test(node.readyState)){\n\t\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tloadDisconnector = domOn(node, \"load\", \"onreadystatechange\", onLoad),\n\t\t\t\t\terrorDisconnector = domOn(node, \"error\", \"onerror\", function(e){\n\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\tsignal(error, makeError(\"scriptError: \" + url, [url, e]));\n\t\t\t\t\t});\n\n\t\t\t\tnode.type = \"text/javascript\";\n\t\t\t\tnode.charset = \"utf-8\";\n\t\t\t\tnode.src = url;\n\t\t\t\tinsertPointSibling.parentNode.insertBefore(node, insertPointSibling);\n\t\t\t\treturn node;\n\t\t\t};\n\t\t}\n\t}\n\n\tif( 0 ){\n\t\treq.log = function(){\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\t\t\tconsole.log(arguments[i]);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t};\n\t}else{\n\t\treq.log = noop;\n\t}\n\n\tif( 0 ){\n\t\tvar trace = req.trace = function(\n\t\t\tgroup,\t// the trace group to which this application belongs\n\t\t\targs\t// the contents of the trace\n\t\t){\n\t\t\t///\n\t\t\t// Tracing interface by group.\n\t\t\t//\n\t\t\t// Sends the contents of args to the console iff (req.trace.on && req.trace[group])\n\n\t\t\tif(trace.on && trace.group[group]){\n\t\t\t\tsignal(\"trace\", [group, args]);\n\t\t\t\tfor(var arg, dump = [], text= \"trace:\" + group + (args.length ? (\":\" + args[0]) : \"\"), i= 1; i<args.length;){\n\t\t\t\t\targ = args[i++];\n\t\t\t\t\tif(isString(arg)){\n\t\t\t\t\t\ttext += \", \" + arg;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdump.push(arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.log(text);\n\t\t\t\tdump.length && dump.push(\".\");\n\t\t\t\treq.log.apply(req, dump);\n\t\t\t}\n\t\t};\n\t\tmix(trace, {\n\t\t\ton:1,\n\t\t\tgroup:{},\n\t\t\tset:function(group, value){\n\t\t\t\tif(isString(group)){\n\t\t\t\t\ttrace.group[group]= value;\n\t\t\t\t}else{\n\t\t\t\t\tmix(trace.group, group);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttrace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));\n\t\ton(\"config\", function(config){\n\t\t\tconfig.trace && trace.set(config.trace);\n\t\t});\n\t}else{\n\t\treq.trace = noop;\n\t}\n\tif (! 1 ) {\n\t\tvar def = function(\n\t\t\tmid,\t\t  //(commonjs.moduleId, optional)\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\t\tfactory\t\t  //(any)\n\t\t){\n\t\t\t///\n\t\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t\t///\n\t\t\t//note\n\t\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\t\tvar arity = arguments.length,\n\t\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"],\n\t\t\t\t// the predominate signature...\n\t\t\t\targs = [0, mid, dependencies];\n\t\t\tif(arity==1){\n\t\t\t\targs = [0, (isFunction(mid) ? defaultDeps : []), mid];\n\t\t\t}else if(arity==2 && isString(mid)){\n\t\t\t\targs = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];\n\t\t\t}else if(arity==3){\n\t\t\t\targs = [mid, dependencies, factory];\n\t\t\t}\n\n\t\t\tif( 0  && args[1]===defaultDeps){\n\t\t\t\targs[2].toString()\n\t\t\t\t\t.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\")\n\t\t\t\t\t.replace(/require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g, function(match, dep){\n\t\t\t\t\targs[1].push(dep);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\t\tmodule;\n\t\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t}else if(! 0  || ! 1  || injectingCachedModule){\n\t\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\t\tdefQ.push(args);\n\t\t\t}else{\n\t\t\t\t// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,\n\t\t\t\t// in-order exec of onLoad with script eval (since it's IE) and must manually detect here\n\t\t\t\ttargetModule = targetModule || injectingModule;\n\t\t\t\tif(!targetModule){\n\t\t\t\t\tfor(mid in waiting){\n\t\t\t\t\t\tmodule = modules[mid];\n\t\t\t\t\t\tif(module && module.node && module.node.readyState === 'interactive'){\n\t\t\t\t\t\t\ttargetModule = module;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( 0  && !targetModule){\n\t\t\t\t\t\tfor(var i = 0; i<combosPending.length; i++){\n\t\t\t\t\t\t\ttargetModule = combosPending[i];\n\t\t\t\t\t\t\tif(targetModule.node && targetModule.node.readyState === 'interactive'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttargetModule= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( 0  && isArray(targetModule)){\n\t\t\t\t\tinjectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));\n\t\t\t\t\tif(!targetModule.length){\n\t\t\t\t\t\tcombosPending.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}else if(targetModule){\n\t\t\t\t\tconsumePendingCacheInsert(targetModule);\n\t\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t\t}else{\n\t\t\t\t\tsignal(error, makeError(\"ieDefineFailed\", args[0]));\n\t\t\t\t}\n\t\t\t\tcheckComplete();\n\t\t\t}\n\t\t};\n\t\tdef.amd = {\n\t\t\tvendor:\"dojotoolkit.org\"\n\t\t};\n\n\t\tif( 0 ){\n\t\t\treq.def = def;\n\t\t}\n\t} else {\n\t\tvar def = noop;\n\t}\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif( 0 ){\n\t\tmix(req, {\n\t\t\t// these may be interesting to look at when debugging\n\t\t\tpaths:paths,\n\t\t\taliases:aliases,\n\t\t\tmodules:modules,\n\t\t\tlegacyMode:legacyMode,\n\t\t\texecQ:execQ,\n\t\t\tdefQ:defQ,\n\t\t\twaiting:waiting,\n\n\t\t\t// these are used for testing\n\t\t\t// TODO: move testing infrastructure to a different has feature\n\t\t\tpacks:packs,\n\t\t\tmapProgs:mapProgs,\n\t\t\tpathsMapProg:pathsMapProg,\n\t\t\tlistenerQueues:listenerQueues,\n\n\t\t\t// these are used by the builder (at least)\n\t\t\tcomputeMapProg:computeMapProg,\n\t\t\tcomputeAliases:computeAliases,\n\t\t\trunMapProg:runMapProg,\n\t\t\tcompactPath:compactPath,\n\t\t\tgetModuleInfo:getModuleInfo_\n\t\t});\n\t}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif( 0 ){\n\t\t\tsignal(error, makeError(\"defineAlreadyDefined\", 0));\n\t\t}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif( 0 ){\n\t\t\trequire = req;\n\t\t}\n\t}\n\n\tif( 0  && req.combo && req.combo.plugins){\n\t\tvar plugins = req.combo.plugins,\n\t\t\tpluginName;\n\t\tfor(pluginName in plugins){\n\t\t\tmix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:\"executed\", load:1});\n\t\t}\n\t}\n\n\tif( 0  && ! 1 ){\n\t\tforEach(delayedModuleConfig, function(c){ config(c); });\n\t\tvar bootDeps = dojoSniffConfig.deps ||\tuserConfig.deps || defaultConfig.deps,\n\t\t\tbootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;\n\t\treq.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;\n\t}\n\tif(! 1 ){\n\t\t!req.async && req([\"dojo\"]);\n\t\treq.boot && req.apply(null, req.boot);\n\t}\n})\n.call(this, userConfig, defaultConfig);};"],"sourceRoot":""}